import java.awt.*;
import java.util.*;
import java.util.List;

/**
 * Defines a board that represents the game state of the roguelike game
 * and also contain some logic to randomly create rooms in the board
 * and display the current state of the board to the terminal
 * @author Phuoc Ha
 */
public class Board {
    private final char[][] grid;
    private char lastMove = ' ';
    private Map<Point, GameCharacter> charactersMap = new HashMap<>();
    private int playerX;
    private int playerY;
    private static final char PLAYER_SYMBOL = '*';
    private static final char EMPTY_SYMBOL = ' ';
    private static final char DOOR_SYMBOL = '+';
    private static final char VERTICAL_BARRIER = '-';
    private static final char HORIZONTAL_BARRIER = '|';
    private static final char NPC_SYMBOL = 'N';

    private Player player = new Player("Explorer", 100, 10, 10);



    public Board(int width, int height) {
        // height preservation for other part of the game
        height -= 1;
        grid = new char[height][width];
        for (int i = 0; i < height; i++) {
            for (int j = 0; j < width; j++) {
                if (i == height - 1 || i == 0) {
                    grid[i][j] = '-';
                } else if (j == width - 1 || j == 0) {
                    grid[i][j] = '|';
                } else {
                    grid[i][j] = EMPTY_SYMBOL;
                }
            }
        }

        // Starting position of the player in the center
        playerX = width / 2;
        playerY = height / 2;
        grid[playerY][playerX] = PLAYER_SYMBOL;

        // generating room to be placed in the board grid
        List<Room> rooms = generateRandomRooms(20, width / 4, height / 4, width / 7, height / 7);        applyRoom(rooms);
    }

    /**
     * This functions intakes a list of rooms and draw them on the board {@link Board#grid}
     * and as well draw the door for each of them based on the information the {@link Room} class
     * provide
     * @param rooms a list of room that are randomly generated by {@link Board#generateRandomRooms(int, int, int, int, int)}
     */
    private void applyRoom(List<Room> rooms) {
        for (Room room : rooms) {
            int r = room.getY();
            int c = room.getX();
            int roomWidth = room.getWidth();
            int roomHeight = room.getHeight();
            // construct each room in the grid horizontally and vertically
            for (int i = 0; i <= roomWidth; i++) {
                grid[r][c + i] = '-';
                grid[r + roomHeight][c + i] = '-';
            }
            for (int i = 0; i < roomHeight; i++) {
                grid[r + i][c] = '|';
                grid[r + i][c + roomWidth] = '|';
            }

            // create door for the room in the grid
            for (DoorDirection doorDirection : room.getDoorDirection()) {
                switch (doorDirection) {
                    case TOP : {
                        grid[r][c + roomWidth / 2] = DOOR_SYMBOL;
                        break;
                    }
                    case BOTTOM : {
                        grid[r + roomHeight][c + roomWidth / 2] = DOOR_SYMBOL;
                        break;
                    }
                    case LEFT : {
                        grid[r + roomHeight / 2][c] = DOOR_SYMBOL;
                        break;
                    }
                    default : {
                        grid[r + roomHeight / 2][c  + roomWidth] = DOOR_SYMBOL;
                    }
                }
            }
            // create NPC
            randomlyCreateNPC(r+1, c+1);

        }
    }

    private void randomlyCreateNPC(int row, int col) {
        Random random = new Random();
        int randomNumber = random.nextInt(2);
        if (randomNumber == 0) {
            grid[row][col] = NPC_SYMBOL;
            charactersMap.put(new Point(row, col), new NPC("NPC", 0, 0, "Hi, I am a merchant", true));
        }
    }

    /**
     * display the board {@link Board#grid} to the terminal with the help
     * of the ANSI escape code to move the cursor to the new line to be compatible with {@link TerminalGame}
     */
    public void display() {
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                System.out.print(grid[i][j]);
            }
            if (i != grid.length - 1) {
                System.out.print('\r');  // Move cursor to the start of the line
                System.out.println();   // Move cursor to the next line
            }
        }
        System.out.print(player.getStatInfo());
    }

    /**
     * move the player around with the given offset
     * @param deltaX x-axis offset
     * @param deltaY y-axis offset
     */
    public void movePlayer(int deltaX, int deltaY) {
        int newX = playerX + deltaX;
        int newY = playerY + deltaY;
        char cur = grid[newY][newX];
        if (isValidMove(newX, newY) && (cur == EMPTY_SYMBOL || cur == DOOR_SYMBOL)) {
            grid[playerY][playerX] = lastMove;
            playerX = newX;
            playerY = newY;
            lastMove = grid[playerY][playerX];
            grid[playerY][playerX] = PLAYER_SYMBOL;
        }
    }

    /**
     * checking if we are moving out of bound
     * @param x x-coordinate
     * @param y y-coordinate
     * @return boolean to indicate if the move is valid
     */
    private boolean isValidMove(int x, int y) {
        return x >= 0 && x < grid[0].length && y >= 0 && y < grid.length;
    }

    /**
     * Random rooms generation with the maximum possible room and interval for
     * the width and height of the room. No two rooms will intersect will each other using
     * the utility function {@link Room#intersects(Room)}
     * @param maxRooms the maximum number of room that can be generated (normally not reached)
     * @param maxWidth maximum possible width of a room
     * @param maxHeight maximum possible height of a room
     * @param minWidth minimum width of a room
     * @param minHeight minimum height of a room
     * @return a list of room that later will be drawn on the board {@link Board#grid}
     */
    private List<Room> generateRandomRooms(int maxRooms, int maxWidth, int maxHeight, int minWidth, int minHeight) {
        List<Room> rooms = new ArrayList<>();
        // create room in the middle where player spawns
        rooms.add(new Room(playerX - 20, playerY - 5, 40 , 10,
                List.of(DoorDirection.TOP, DoorDirection.LEFT, DoorDirection.BOTTOM, DoorDirection.RIGHT)));

        int gridWidth = grid[0].length;
        int gridHeight = grid.length;
        Random rand = new Random();
        for (int i = 0; i < maxRooms; i++) {
            int width = rand.nextInt(maxWidth - minWidth) + minWidth + 1;
            int height = rand.nextInt(maxHeight - minHeight) + minHeight + 1;
            int x = rand.nextInt(gridWidth - width);
            int y = rand.nextInt(gridHeight - height);

            Room newRoom = new Room(x, y, width, height, calculateDoorPlacement(x, y));

            boolean intersect = false;

            for (Room room : rooms) {
                if (newRoom.intersects(room)) {
                    intersect = true;
                    break;
                }
            }

            if (!intersect) {
                rooms.add(newRoom);
            }
        }
        return rooms;
    }

    /**
     * Assigns suitable {@link DoorDirection} to a room by identifying
     * which segment of the board the room is located in
     * @param x the x value of the starting point of the room
     * @param y the y value of the starting point of the room
     * @return the list of {@link DoorDirection} that a room need
     */
    private List<DoorDirection> calculateDoorPlacement(int x, int y) {
        List<DoorDirection> res = new ArrayList<>();
        int halfHeight = grid.length / 2;
        int halfWidth = grid[0].length / 2;
        if (x < halfWidth) {
            res.add(DoorDirection.RIGHT);
        } else {
            res.add(DoorDirection.LEFT);
        }
        if (y < halfHeight) {
            res.add(DoorDirection.BOTTOM);
        } else {
            res.add(DoorDirection.TOP);
        }
        return res;
    }

    public GameCharacter getNearbyCharacter() {
        // Check tiles around (playerX, playerY) for characters
        for (int i = playerY - 1; i <= playerY + 1; i++) {
            for (int j = playerX - 1; j <= playerX + 1; j++) {
                if (i >= 0 && i < grid.length && j >= 0 && j < grid[i].length) { // Check boundaries
                    if (grid[i][j] == NPC_SYMBOL) { // Found an NPC
                        return charactersMap.get(new Point(i, j)); // Return the actual Character object
                    }
                }
            }
        }
        return null; // no nearby character found
    }

    public GameCharacter getAttackableTarget() {
        // Check tiles around (playerX, playerY) for potential targets
        for (int i = playerX - 1; i <= playerX + 1; i++) {
            for (int j = playerY - 1; j <= playerY + 1; j++) {
                // Check boundaries and ensure it's not the player's position
                if (i >= 0 && i < grid.length && j >= 0 && j < grid[i].length && !(i == playerX && j == playerY)) {
                    if (grid[i][j] == 'N') { // Found an NPC which is a potential target
                        return charactersMap.get(new Point(i, j)); // Return the actual Character object
                    }
                }
            }
        }
        return null; // No attackable target found
    }


    public Player getPlayer() {
        return this.player;
    }






}