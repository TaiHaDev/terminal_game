import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * Defines a board that represents the game state of the roguelike game
 * and also contain some logic to randomly create rooms in the board
 * and display the current state of the board to the terminal
 * @author Phuoc Ha
 */
public class Board {
    private final char[][] grid;
    private int playerX;
    private int playerY;
    private GameStat gameStat = new GameStat(100, 0, 10, 10);
    private static final char PLAYER_SYMBOL = '*';
    private static final char EMPTY_SYMBOL = ' ';
    private static final char DOOR_SYMBOL = '+';
    private static final char VERTICAL_BARRIER = '-';
    private static final char HORIZONTAL_BARRIER = '|';



    public Board(int width, int height) {
        // height preservation for other part of the game
        height -= 1;
        grid = new char[height][width];
        for (int i = 0; i < height; i++) {
            for (int j = 0; j < width; j++) {
                if (i == height - 1 || i == 0) {
                    grid[i][j] = '-';
                } else if (j == width - 1 || j == 0) {
                    grid[i][j] = '|';
                } else {
                    grid[i][j] = EMPTY_SYMBOL;
                }
            }
        }

        // Starting position of the player in the center
        playerX = width / 2;
        playerY = height / 2;
        grid[playerY][playerX] = PLAYER_SYMBOL;

        // generating room to be placed in the board grid
        List<Room> rooms = generateRandomRooms(16, 70, 15, 45, 5);
        applyRoom(rooms);
    }

    /**
     * This functions intakes a list of rooms and draw them on the board {@link Board#grid}
     * and as well draw the door for each of them based on the information the {@link Room} class
     * provide
     * @param rooms a list of room that are randomly generated by {@link Board#generateRandomRooms(int, int, int, int, int)}
     */
    private void applyRoom(List<Room> rooms) {
        for (Room room : rooms) {
            int r = room.getY();
            int c = room.getX();
            int roomWidth = room.getWidth();
            int roomHeight = room.getHeight();
            // construct each room in the grid horizontally and vertically
            for (int i = 0; i <= roomWidth; i++) {
                grid[r][c + i] = '-';
                grid[r + roomHeight][c + i] = '-';
            }
            for (int i = 0; i < roomHeight; i++) {
                grid[r + i][c] = '|';
                grid[r + i][c + roomWidth] = '|';
            }

            // create door for the room in the grid
            for (DoorDirection doorDirection : room.getDoorDirection()) {
                switch (doorDirection) {
                    case TOP -> {
                        grid[r][c + roomWidth / 2] = DOOR_SYMBOL;
                    }
                    case BOTTOM -> {
                        grid[r + roomHeight][c + roomWidth / 2] = DOOR_SYMBOL;
                    }
                    case LEFT -> {
                        grid[r + roomHeight / 2][c] = DOOR_SYMBOL;
                    }
                    default -> {
                        grid[r + roomHeight / 2][c  + roomWidth] = DOOR_SYMBOL;
                    }
                }
            }
        }
    }

    /**
     * display the board {@link Board#grid} to the terminal with the help
     * of the ANSI escape code to move the cursor to the new line to be compatible with {@link TerminalGame}
     */
    public void display() {
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                System.out.print(grid[i][j]);
            }
            if (i != grid.length - 1) {
                System.out.print('\r');  // Move cursor to the start of the line
                System.out.println();   // Move cursor to the next line
            }
        }
        System.out.print(gameStat);
    }

    /**
     * move the player around with the given offset
     * @param deltaX x-axis offset
     * @param deltaY y-axis offset
     */
    public void movePlayer(int deltaX, int deltaY) {
        int newX = playerX + deltaX;
        int newY = playerY + deltaY;
        char cur = grid[newY][newX];
        if (isValidMove(newX, newY) && cur != VERTICAL_BARRIER && cur != HORIZONTAL_BARRIER) {
            grid[playerY][playerX] = EMPTY_SYMBOL;
            playerX = newX;
            playerY = newY;
            grid[playerY][playerX] = PLAYER_SYMBOL;
        }
    }

    private boolean isValidMove(int x, int y) {
        return x >= 0 && x < grid[0].length && y >= 0 && y < grid.length;
    }

    /**
     * Random rooms generation with the maximum possible room and interval for
     * the width and height of the room. No two rooms will intersect will each other using
     * the utility function {@link Room#intersects(Room)}
     * @param maxRooms the maximum number of room that can be generated (normally not reached)
     * @param maxWidth maximum possible width of a room
     * @param maxHeight maximum possible height of a room
     * @param minWidth minimum width of a room
     * @param minHeight minimum height of a room
     * @return a list of room that later will be drawn on the board {@link Board#grid}
     */
    private List<Room> generateRandomRooms(int maxRooms, int maxWidth, int maxHeight, int minWidth, int minHeight) {
        List<Room> rooms = new ArrayList<>();
        // create room in the middle where player spawns
        rooms.add(new Room(playerX - 20, playerY - 5, 40 , 10,
                List.of(DoorDirection.TOP, DoorDirection.LEFT, DoorDirection.BOTTOM, DoorDirection.RIGHT)));

        int gridWidth = grid[0].length;
        int gridHeight = grid.length;
        Random rand = new Random();
        for (int i = 0; i < maxRooms; i++) {
            int width = rand.nextInt(maxWidth - minWidth) + minWidth + 1;
            int height = rand.nextInt(maxHeight - minHeight) + minHeight + 1;
            int x = rand.nextInt(gridWidth - width);
            int y = rand.nextInt(gridHeight - height);

            Room newRoom = new Room(x, y, width, height, calculateDoorPlacement(x, y));

            boolean intersect = false;

            for (Room room : rooms) {
                if (newRoom.intersects(room)) {
                    intersect = true;
                    break;
                }
            }

            if (!intersect) {
                rooms.add(newRoom);
            }
        }
        return rooms;
    }

    /**
     * Assigns suitable {@link DoorDirection} to a room by identifying
     * which segment of the board the room is located in
     * @param x the x value of the starting point of the room
     * @param y the y value of the starting point of the room
     * @return the list of {@link DoorDirection} that a room need
     */
    private List<DoorDirection> calculateDoorPlacement(int x, int y) {
        List<DoorDirection> res = new ArrayList<>();
        int halfHeight = grid.length / 2;
        int halfWidth = grid[0].length / 2;
        if (x < halfWidth) {
            res.add(DoorDirection.RIGHT);
        } else {
            res.add(DoorDirection.LEFT);
        }
        if (y < halfHeight) {
            res.add(DoorDirection.BOTTOM);
        } else {
            res.add(DoorDirection.TOP);
        }
        return res;
    }
}